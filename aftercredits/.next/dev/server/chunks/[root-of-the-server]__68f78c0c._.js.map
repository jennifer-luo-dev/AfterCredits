{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/jennifer/personalprojects/AfterCredits/aftercredits/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\ndeclare global {\n  // allow global prisma across hot reloads in dev\n  // eslint-disable-next-line no-var\n  var __prisma: PrismaClient | undefined;\n}\n\nexport const prisma = global.__prisma ?? new PrismaClient();\nif (process.env.NODE_ENV !== \"production\") global.__prisma = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAQO,MAAM,SAAS,OAAO,QAAQ,IAAI,IAAI,0PAAY;AACzD,wCAA2C,OAAO,QAAQ,GAAG"}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/jennifer/personalprojects/AfterCredits/aftercredits/src/app/api/memory/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { prisma } from \"../../../lib/prisma\";\nimport { createClient as createSupabaseClient } from \"@supabase/supabase-js\";\n\nconst SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;\nconst supabaseAdmin =\n  SUPABASE_URL && SUPABASE_SERVICE_ROLE_KEY\n    ? createSupabaseClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)\n    : null;\n\n// GET /api/memory - list memories\nexport async function GET(request: Request) {\n  const url = new URL(request.url);\n  const userId = url.searchParams.get(\"userId\");\n  // Build options dynamically and avoid strict typing issues\n  const findOptions: any = { orderBy: { createdAt: \"desc\" } };\n  if (userId) findOptions.where = { userId };\n  const memories = await prisma.memory.findMany(findOptions);\n\n  // If we have a SUPABASE_SERVICE_ROLE_KEY, generate short-lived signed urls for private images\n  if (supabaseAdmin) {\n    const withUrls = await Promise.all(\n      memories.map(async (m: any) => {\n        const result: any = { ...m };\n\n        // Handle imagePath (legacy single image)\n        if (m.imagePath) {\n          try {\n            // Check if imagePath is a folder by trying to list its contents\n            const { data: files, error: listError } =\n              await supabaseAdmin.storage.from(\"memories\").list(m.imagePath);\n\n            if (!listError && files && files.length > 0) {\n              // imagePath is a folder - get the first file\n              const firstFile = files.find(\n                (f: any) => f.name !== \".emptyFolderPlaceholder\"\n              );\n              if (firstFile) {\n                const filePath = `${m.imagePath}/${firstFile.name}`;\n                const { data, error } = await supabaseAdmin.storage\n                  .from(\"memories\")\n                  .createSignedUrl(filePath, 60 * 15);\n                if (!error && data?.signedUrl) {\n                  result.imageSrc = data.signedUrl;\n                }\n              }\n            } else if (!listError) {\n              // imagePath is likely a single file, not a folder - try to create signed URL directly\n              const { data, error } = await supabaseAdmin.storage\n                .from(\"memories\")\n                .createSignedUrl(m.imagePath, 60 * 15);\n              if (!error && data?.signedUrl) {\n                result.imageSrc = data.signedUrl;\n              }\n            }\n\n            if (!result.imageSrc) {\n              console.warn(\"Could not create signed URL for\", m.imagePath);\n            }\n          } catch (err) {\n            console.warn(\"Failed to create signed URL\", err);\n          }\n        }\n\n        // Handle imagePaths array (multiple images)\n        if (\n          m.imagePaths &&\n          Array.isArray(m.imagePaths) &&\n          m.imagePaths.length > 0\n        ) {\n          try {\n            const signedUrls = await Promise.all(\n              m.imagePaths.map(async (path: string) => {\n                try {\n                  const { data, error } = await supabaseAdmin.storage\n                    .from(\"memories\")\n                    .createSignedUrl(path, 60 * 15);\n                  if (!error && data?.signedUrl) {\n                    return data.signedUrl;\n                  }\n                  console.warn(\"Could not create signed URL for\", path);\n                  return null;\n                } catch (err) {\n                  console.warn(\"Failed to create signed URL for\", path, err);\n                  return null;\n                }\n              })\n            );\n            // Filter out any null values from failed URL generations\n            result.imageSignedUrls = signedUrls.filter((url) => url !== null);\n          } catch (err) {\n            console.warn(\"Failed to process imagePaths array\", err);\n          }\n        }\n\n        return result;\n      })\n    );\n    return NextResponse.json(withUrls);\n  }\n\n  // No service role key available. Attempt a best-effort public URL fallback\n  // (this will only work if your \"memories\" bucket is public). For private\n  // buckets you should set SUPABASE_SERVICE_ROLE_KEY in your environment so\n  // the server can generate signed URLs.\n  const withFallback = memories.map((m: any) => ({\n    ...m,\n    imageSrc:\n      m.imageUrl ??\n      (SUPABASE_URL && m.imagePath\n        ? `${SUPABASE_URL}/storage/v1/object/public/memories/${encodeURIComponent(\n            m.imagePath\n          )}`\n        : null),\n  }));\n\n  return NextResponse.json(withFallback);\n}\n\n// POST /api/memory - create a memory\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n    const { title, date, location, description, imagePaths, userId } = body;\n\n    const data: any = {\n      title,\n      location: location ?? null,\n      description: description ?? null,\n      imagePaths: imagePaths ?? [],\n      userId: userId ?? null,\n    };\n\n    console.log(\"REQ BODY:\", body);\n    // Memory model requires a DateTime `date`. Default to now if missing.\n    data.date = date ? new Date(date) : new Date();\n\n    const memory = await prisma.memory.create({ data });\n\n    return NextResponse.json(memory, { status: 201 });\n  } catch (err: any) {\n    console.error(\"Failed to create memory:\", err);\n    // Return the actual error message so the client can show helpful info\n    const message = err?.message ?? \"Failed to create memory\";\n    return NextResponse.json({ error: message }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":"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"}}]
}