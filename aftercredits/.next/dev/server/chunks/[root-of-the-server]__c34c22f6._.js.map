{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///Users/jennifer/personalprojects/AfterCredits/aftercredits/src/app/api/memory/route.ts"],"sourcesContent":["// app/api/memory/route.ts\n\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { PrismaClient } from \"@prisma/client\";\nimport { createClient } from \"@supabase/supabase-js\";\n\nconst prisma = new PrismaClient();\n\n// POST - Create new memory\nexport async function POST(req: NextRequest) {\n  try {\n    const body = await req.json();\n    const { title, date, location, description, imagePaths, userId } = body;\n\n    if (!title || !date) {\n      return NextResponse.json(\n        { error: \"Title and date are required\" },\n        { status: 400 }\n      );\n    }\n\n    // Create memory with array of image paths\n    const memory = await prisma.memory.create({\n      data: {\n        title,\n        date: new Date(date),\n        location: location || null,\n        description: description || null,\n        imagePaths: imagePaths || [], // Store array of paths\n        userId: userId || null,\n      },\n    });\n\n    return NextResponse.json(memory, { status: 201 });\n  } catch (error: any) {\n    console.error(\"Error creating memory:\", error);\n    return NextResponse.json(\n      { error: error.message || \"Failed to create memory\" },\n      { status: 500 }\n    );\n  }\n}\n\n// GET - Fetch all memories with signed URLs\nexport async function GET(req: NextRequest) {\n  try {\n    const supabase = createClient();\n\n    const memories = await prisma.memory.findMany({\n      orderBy: { date: \"desc\" },\n    });\n\n    // Generate signed URLs for all images in each memory\n    const memoriesWithUrls = await Promise.all(\n      memories.map(async (memory) => {\n        let imageUrls: string[] = [];\n\n        if (memory.imagePaths && memory.imagePaths.length > 0) {\n          // Generate signed URLs for all images\n          imageUrls = await Promise.all(\n            memory.imagePaths.map(async (path) => {\n              const { data } = await supabase.storage\n                .from(\"memories\")\n                .createSignedUrl(path, 60 * 60); // 1 hour expiry\n              return data?.signedUrl || \"\";\n            })\n          );\n          imageUrls = imageUrls.filter(Boolean); // Remove empty URLs\n        } else if (memory.imagePath) {\n          // Backwards compatibility: handle old single imagePath\n          const { data } = await supabase.storage\n            .from(\"memories\")\n            .createSignedUrl(memory.imagePath, 60 * 60);\n          if (data?.signedUrl) imageUrls.push(data.signedUrl);\n        }\n\n        return {\n          ...memory,\n          imageUrls, // Array of signed URLs\n          imageSrc: imageUrls[0] || null, // First image for backwards compatibility\n        };\n      })\n    );\n\n    return NextResponse.json(memoriesWithUrls);\n  } catch (error: any) {\n    console.error(\"Error fetching memories:\", error);\n    return NextResponse.json(\n      { error: error.message || \"Failed to fetch memories\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"AAAA,0BAA0B;;;;;;;AAE1B;AACA;AACA;;;;AAEA,MAAM,SAAS,IAAI,6IAAY;AAGxB,eAAe,KAAK,GAAgB;IACzC,IAAI;QACF,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,UAAU,EAAE,MAAM,EAAE,GAAG;QAEnE,IAAI,CAAC,SAAS,CAAC,MAAM;YACnB,OAAO,oMAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA8B,GACvC;gBAAE,QAAQ;YAAI;QAElB;QAEA,0CAA0C;QAC1C,MAAM,SAAS,MAAM,OAAO,MAAM,CAAC,MAAM,CAAC;YACxC,MAAM;gBACJ;gBACA,MAAM,IAAI,KAAK;gBACf,UAAU,YAAY;gBACtB,aAAa,eAAe;gBAC5B,YAAY,cAAc,EAAE;gBAC5B,QAAQ,UAAU;YACpB;QACF;QAEA,OAAO,oMAAY,CAAC,IAAI,CAAC,QAAQ;YAAE,QAAQ;QAAI;IACjD,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO,oMAAY,CAAC,IAAI,CACtB;YAAE,OAAO,MAAM,OAAO,IAAI;QAA0B,GACpD;YAAE,QAAQ;QAAI;IAElB;AACF;AAGO,eAAe,IAAI,GAAgB;IACxC,IAAI;QACF,MAAM,WAAW,IAAA,6PAAY;QAE7B,MAAM,WAAW,MAAM,OAAO,MAAM,CAAC,QAAQ,CAAC;YAC5C,SAAS;gBAAE,MAAM;YAAO;QAC1B;QAEA,qDAAqD;QACrD,MAAM,mBAAmB,MAAM,QAAQ,GAAG,CACxC,SAAS,GAAG,CAAC,OAAO;YAClB,IAAI,YAAsB,EAAE;YAE5B,IAAI,OAAO,UAAU,IAAI,OAAO,UAAU,CAAC,MAAM,GAAG,GAAG;gBACrD,sCAAsC;gBACtC,YAAY,MAAM,QAAQ,GAAG,CAC3B,OAAO,UAAU,CAAC,GAAG,CAAC,OAAO;oBAC3B,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,SAAS,OAAO,CACpC,IAAI,CAAC,YACL,eAAe,CAAC,MAAM,KAAK,KAAK,gBAAgB;oBACnD,OAAO,MAAM,aAAa;gBAC5B;gBAEF,YAAY,UAAU,MAAM,CAAC,UAAU,oBAAoB;YAC7D,OAAO,IAAI,OAAO,SAAS,EAAE;gBAC3B,uDAAuD;gBACvD,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,SAAS,OAAO,CACpC,IAAI,CAAC,YACL,eAAe,CAAC,OAAO,SAAS,EAAE,KAAK;gBAC1C,IAAI,MAAM,WAAW,UAAU,IAAI,CAAC,KAAK,SAAS;YACpD;YAEA,OAAO;gBACL,GAAG,MAAM;gBACT;gBACA,UAAU,SAAS,CAAC,EAAE,IAAI;YAC5B;QACF;QAGF,OAAO,oMAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,oMAAY,CAAC,IAAI,CACtB;YAAE,OAAO,MAAM,OAAO,IAAI;QAA2B,GACrD;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}